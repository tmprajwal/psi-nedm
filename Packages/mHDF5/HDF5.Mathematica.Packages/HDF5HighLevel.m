(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["HDF5HighLevel`",{"HDF5`","HDF5Basic`","HDF5Extend`","NETLink`"}]


(* ::Input::Initialization:: *)
$HDF5HighLevelPackageVersion="V2.00"


(* ::Input::Initialization:: *)
NamesAndTypesAtOneNode::usage=
"NamesAndTypesAtOneNode[\"GroupOrFileID\"] returns a list of {{\"Name\", \"Type\"}, ...} for all subnodes of the node indicated by the GroupOrFileID.\n\nThe function takes the option \"IncludeAddress\", which is False by default.\n\n(This function was changed in V2.00 to return type by string instead of by value.)"


(* ::Input::Initialization:: *)
NamesAndTypes::usage=
"NamesAndTypesAtOneNode[\"FileName\"] returns a list of rules as {\"Type\"->{\"Name1\", \"Name2\", ... }, ...} for all unique elements in file. Uniqueness is based on address in file. (This function was changed in V2.00 to return type by string instead of by value and to return a list of rules rather than a list of elements.)."


(* ::Input::Initialization:: *)
DataSetDimensions::usage=
"DataSetDimensions[\"FileName\", \"PathToDataSet\"] returns the dimensions of the data set as a list."


(* ::Input::Initialization:: *)
DataSetDataTypeClass::usage=
"DataSetDataTypeClass[\"FileName\", \"PathToDataSet\"] returns the class, as one of \"INTEGER\", \"FLOAT\", \"TIME\", \"STRING\", \"BITFIELD\", \"OPAQUE\", \"COMPOUND\", \"REFERENCE\", \"ENUM\", \"VLEN\", or \"ARRAY\".\n\n(This function was updated in V2.00 to return type by string instead of by value.)"


(* ::Input::Initialization:: *)
DataSetSystemType::usage=
"DataSetSystemType[\"FileName\", \"PathToDataSet\"] returns the system type of the data class, such as \"System.Int32[]\"."


(* ::Input::Initialization:: *)
ReadAttributes::usage=
"ReadAttributes[\"FileName\", \"PathToObject\"] returns metadata and values about the attributes of the object.\n\nThe function takes the option \"ReturnValues\", which is True by default."


(* ::Input::Initialization:: *)
CompoundDataTypeInformation::usage=
"CompoundDataTypeInformation[\"FileName\", \"PathToObject\"] returns metadata about a compound datatype."


(* ::Input::Initialization:: *)
CompoundDataTypeInformationTree::usage=
"CompoundDataTypeInformationTree[\"FileName\", \"PathToObject\"] returns metadata about nested compound datatypes."


(* ::Input::Initialization:: *)
CompoundDataTypeInformation::abort="Abort from CompoundDataTypeInformation[]."


(* ::Input::Initialization:: *)
DataSetsMetaData::usage=
"DataSetsMetaData[\"FileName\"] returns metadata about all datasets in the file."


(* ::Input::Initialization:: *)
ReadHyperSlab::usage=
"ReadHyperSlab[\"FileName\", \"PathToDataSet\", \"Offsets\" as List, \"BlockSizes\" as List] returns one hyperslab of contiguous data from the specified dataset.\n\nThe offset index runs from 1 forward, which is standard Mathematica syntax, rather than 0 forward as in the HDF standard.\n\nIn the case that the list length of \"Offsets\" is less than the rank of the dataset, the function automatically provides the correct values such that the full data range is read in each dimension that is not included. \"Offsets\" and \"BlockSizes\" must have the same length.\n\nThe function takes the options of H5DExtendRead[ ].\n\n(Previously, there was an option \"FinalIndexFull\"; if provided, this option is ignored. All information is in comparison of the length of \"OffsetList\" to the rank of the dataset.)"


(* ::Input::Initialization:: *)
ReadRank1::usage=
"ReadRank1[\"FileName\", \"PathToDataSet\"] returns the data from the specified dataset of rank 1. The function takes the options of ReadHyperSlab[ ]."


(* ::Input::Initialization:: *)
ReadColumnRank1::usage=
"ReadColumnRank1[ ] is functional but deprecated in V2.00. Use instead ReadRank1[ ]."


(* ::Input::Initialization:: *)
ReadRank2::usage=
"ReadRank2[\"FileName\", \"PathToDataSet\"] returns the data from the specified dataset of rank 2. The function takes the options of ReadHyperSlab[ ]."


(* ::Input::Initialization:: *)
ReadColumnRank2::usage=
"ReadColumnRank2[\"FileName\", \"PathToDataSet\", \"Column\"] returns one column of data from the specified dataset of rank 2. The function takes the options of ReadHyperSlab[ ]."


(* ::Input::Initialization:: *)
ReadRowRank2::usage=
"ReadRowRank2[\"FileName\", \"PathToDataSet\", \"Row\"] returns one row of data from the specified dataset of rank 2. The function takes the options of ReadHyperSlab[ ]."


(* ::Input::Initialization:: *)
CompoundDataType`Information::usage=
"In V2.00, now use CompoundDataTypeInformation[ ]."


(* ::Input::Initialization:: *)
CompoundDataType`Values::usage=
"In V2.00, now use H5DExtendRead[ ]."


(* ::Input::Initialization:: *)
ReadElementaryPoints::usage=
"ReadElementaryPoints[\"FileName\", \"PathToDataSet\", \"ElementaryPoints\" as List] returns a list of elementary points from the specified dataset. The point index runs from 1 forward, which is standard Mathematica syntax, rather than 0 forward as in the HDF standard. The function takes the options of H5DExtendRead[ ]."


(* ::Input::Initialization:: *)
Begin["Private`"]


(* ::Input::Initialization:: *)
Options[NamesAndTypesAtOneNode]={"IncludeAddress"->False}


(* ::Input::Initialization:: *)
NamesAndTypesAtOneNode[GroupOrFileID:_Integer,opts:OptionsPattern[]]:=

NETBlock[

With[
{
indexList=Range[0,H5GExtendGetNumObjs[GroupOrFileID]-1],

addressFunction=
If[
OptionValue["IncludeAddress"],
H5OExtendGetInfoByIndex["ObjectAddressInFile"][GroupOrFileID,#],
Nothing
]
},

List[
H5LExtendGetNameByIdx[GroupOrFileID,#],
H5OExtendGetInfoByIndex["TypeAsString"][GroupOrFileID,#],
addressFunction
]&/@indexList

] (* close With *)

](* close NETBlock *)


(* ::Input::Initialization:: *)
NamesAndTypes[filename:_String]:=

With[{listFormat=NamesAndTypes`List[filename]},
With[{gatheredList=Gather[listFormat,Last[#1]==Last[#2]&]},
With[
{
values=gatheredList[[All,All,1]],
label=gatheredList[[All,1,2]]
},

(* return as individual rules *)
Thread[Rule[label,values]]

]
]
]


(* ::Input::Initialization:: *)
NamesAndTypes`List[filename:_String]:=

NETBlock[

Module[

{fileID,returnList={{0,0,0}},groupNamesThisLevel={"."},groupIDsThisLevel,itemsThisLevel,itemsThisLevelNoDuplicates},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

CompoundExpression[

While[

(* so long as there are more groups, continue... *)
Length[groupNamesThisLevel]>0,

CompoundExpression[

(* get list of all group IDs for this level *)
groupIDsThisLevel=H5Gopen[fileID,#,H5PuDEFAULT]&/@groupNamesThisLevel,

(* code below opens all the group IDs on this level, reads in {Name,Type,Address}, and updates to {Group/Name,Type,Address}*)
itemsThisLevel=
Flatten[
Table[
With[
{
(* function to add "group/" at front of name *)
groupNamePrepend=StringJoin[groupNamesThisLevel[[i]],"/",# (* item name *) ]&,
(* list of {name,type} at this ONE group node *)
namesAndTypesThisNode=NamesAndTypesAtOneNode[groupIDsThisLevel[[i]],"IncludeAddress"->True]
},
(* update to "group/name" for ALL items at this ONE group node *)
MapAt[groupNamePrepend,# (* {name,type} *),1]&/@namesAndTypesThisNode
],
(* do updating across ALL group nodes at this ONE level *)
{i,Length@groupIDsThisLevel}
],
1
],

H5Gclose[#]&/@groupIDsThisLevel,

itemsThisLevelNoDuplicates=
With[
{
(* based on address, reject any duplicate returns this level *)
itemsToTestFurther=
DeleteDuplicates[itemsThisLevel,Last[#1]==Last[#2]&],
(* addresses of what we have so far *)
addresses=returnList[[All,3]]
},
(* reject any duplicates already in master list *)
DeleteCases[
itemsToTestFurther,
{_,_,_?(MemberQ[addresses,#]&)}
]
],

(* at this point we keep a master list with duplicates, but we'll get rid of those at the end when we return *)
returnList=returnList~Join~itemsThisLevel,

(* set up for next loop through While[...] *)
groupNamesThisLevel=Cases[itemsThisLevelNoDuplicates,{groupName:_,"GROUP",_ (* memory address *)}:>groupName]

] (* close CompoundExpression *) 
] (*close While*),

(* based on address, no duplicates returned; also, drop the first element which was {0,0,0}; drop the address in the return *)
Rest[DeleteDuplicates[returnList,Last[#1]==Last[#2]&][[All,;;2]]]

] (* close CompoundExpression *) 
] (* close H5FExtendOpen *)
] (* close Module *)
] (* close NETBlock *)


(* ::Input::Initialization:: *)
Options[DataSetsMetaData]={}


(* ::Input::Initialization:: *)
DataSetsMetaData[filename:_String,opts:OptionsPattern[]]:=

Module[

{datasetNamesList,numDatasets,datasetsClassTypeList,datasetSystemTypeList,datasetsDimensionsList,return},

CompoundExpression[

(* get list of data set names *)
datasetNamesList=Replace["DATASET",NamesAndTypes[filename]],

(* in case of no datasets*)
If[MatchQ[datasetNamesList,"DATASET"],datasetNamesList={}],

(* number of data sets*)
numDatasets=Length@datasetNamesList,

(* type as INTEGER, FLOAT, etc. *)
datasetsClassTypeList=Map[DataSetDataTypeClass[filename,#]&][datasetNamesList],

(* type as System.Int32[], etc. *)
datasetSystemTypeList=Map[DataSetSystemType[filename,#]&][datasetNamesList],

(* dimensions of each data set *)
datasetsDimensionsList=Map[DataSetDimensions[filename,#]&][datasetNamesList],

return=
{
"NumberOfDatasets"->numDatasets,
"DatasetName"->datasetNamesList,
"DatasetClassType"->datasetsClassTypeList,
"DatasetSystemType"->datasetSystemTypeList,
"DatasetSpaceDimensions"->datasetsDimensionsList
},

return

](* close CompoundExpression *)
] (* close Module *)



(* ::Input::Initialization:: *)
DataSetDimensions[filename:_String,dataSetPath:_String]:=

Module[
{fileID,dataSetID,dataSpaceID,dataSpaceDimensions,statusFlag},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

H5DExtendOpen[
{dataSetID=H5Dopen[fileID, dataSetPath, H5PuDEFAULT]},

CompoundExpression[
(* get ID's *)
dataSpaceID=H5DgetSpace[dataSetID],
dataSpaceDimensions=H5SBasicGetSimpleExtentDims[dataSpaceID],

(* non-zero StatusFlag indicates an error of some sort occurred*)
statusFlag=H5Sclose[dataSpaceID] ,

(* function's return expression *)
If[Positive[statusFlag],statusFlag,dataSpaceDimensions]
] (* close CompoundExpression *)
] (* close H5DExtendOpen *)
] (* close H5FExtendOpen *)
] (* close Module *)


(* ::Input::Initialization:: *)
DataSetDataTypeClass[filename:_String,dataSetPath:_String]:=

Module[
{fileID,dataSetID,dataTypeID,dataTypeClass,statusFlag},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

H5DExtendOpen[
{dataSetID=H5Dopen[fileID, dataSetPath, H5PuDEFAULT]},

CompoundExpression[
(* get ID's *)
dataTypeID=H5DgetType[dataSetID],

(* "INTEGER", "FLOAT", etc. *)
dataTypeClass=H5TBasicGetClass["String"][dataTypeID] ,

(* non-zero StatusFlag indicates an error of some sort occurred*)
statusFlag=H5Tclose[dataTypeID] ,

(* function's return expression *)
If[Positive[statusFlag],statusFlag,dataTypeClass]
](* close CompoundExpression *)
] (* close H5DExtendOpen *)
] (* close H5FExtendOpen *)
] (* close Module *)


(* ::Input::Initialization:: *)
DataSetSystemType[filename:_String,dataSetPath:_String]:=

Module[
{fileID,dataSetID,dataTypeID,dataTypeClass,statusFlag},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

H5DExtendOpen[
{dataSetID=H5Dopen[fileID, dataSetPath, H5PuDEFAULT]},

CompoundExpression[
(* get ID's *)
dataTypeID=H5DgetType[dataSetID],

(* "System.Int32[]", etc. *)
systemTypeClass=H5TExtendGetSystemType[dataTypeID],

(* non-zero StatusFlag indicates an error of some sort occurred*)
statusFlag=H5Tclose[dataTypeID] ,

(* function's return expression *)
If[Positive[statusFlag],statusFlag,systemTypeClass]
](* close CompoundExpression *)
] (* close H5DExtendOpen *)
] (* close H5FExtendOpen *)
] (* close Module *)


(* ::Input::Initialization:: *)
Options[ReadAttributes]={"ReturnValues"->True}


(* ::Input::Initialization:: *)
ReadAttributes[filename:_String,object:_String,opts:OptionsPattern[]]:=

NETBlock[

Module[

{fileID,objectID,numAttributes,attributeIndexList,attributeIDlist,attributeNamelist,attributeDataTypeIDlist,attributeDataSpaceIDlist,attributeDataSpaceDimensionsList,attributeDataTypeClassList,attributeSystemTypeList,attributeSystemTypeCountInOneDatumList,attributeValues,return},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

CompoundExpression[

objectID=H5Oopen[fileID,object,H5PuDEFAULT],

numAttributes=H5OExtendGetInfo["NumberAttributes"][objectID],
attributeIndexList=Range[0,numAttributes-1],

attributeIDlist=
Map[
H5AopenByIdx[objectID,".",H5uINDEXuNAME,H5uITERuINC,#,H5PuDEFAULT,H5PuDEFAULT]&,
attributeIndexList
],

attributeDataTypeIDlist=Map[H5AgetType][attributeIDlist],

attributeNamelist=Map[H5AExtendGetName][attributeIDlist],

attributeDataTypeClassList=Map[H5TBasicGetClass["String"]][attributeDataTypeIDlist],
attributeSystemTypeList=Map[H5TExtendGetSystemType][attributeDataTypeIDlist],
attributeSystemTypeCountInOneDatumList=Map[H5TExtendGetSystemTypeCountInOneDatum][attributeDataTypeIDlist],

attributeDataSpaceIDlist=Map[H5AgetSpace][attributeIDlist],
attributeDataSpaceDimensionsList=Map[H5SBasicGetSimpleExtentDims][attributeDataSpaceIDlist],

attributeValues=
If[
OptionValue["ReturnValues"],
Map[H5AExtendRead][attributeIDlist],
Missing["NotRequested"]
],

return=
{
"NumberOfAttributes"->numAttributes,
"AttributeName"->attributeNamelist,
"AttributeClassType"->attributeDataTypeClassList,
"AttributeSystemType"->attributeSystemTypeList,
"AttributeSystemTypeCountInOneDatum"->attributeSystemTypeCountInOneDatumList,
"AttributeSpaceDimensions"->attributeDataSpaceDimensionsList,
"AttributeValues"->attributeValues
},

(* close out everything *)
Map[H5Aclose][attributeIDlist],
Map[H5Tclose][attributeDataTypeIDlist],
Map[H5Sclose][attributeDataSpaceIDlist],

H5Oclose[objectID],

return

](* close CompoundExpression *)
] (* close H5FExtendOpen *)
] (* close Module *)
] (* close NETBlock *)


(* ::Input::Initialization:: *)
CompoundDataTypeInformation[filename:_String,dataSetPath:_String]:=

Module[
{fileID,dataSetID,compoundDataTypeID,numMembers,memberNames,memberDataTypeIDs,memberClasses,memberSystemTypes,memberSystemTypeCountInOneDatumList,statusFlag,return},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

H5DExtendOpen[
{dataSetID=H5Dopen[fileID, dataSetPath, H5PuDEFAULT]},

CompoundExpression[
(* get ID's *)
compoundDataTypeID=H5DgetType[dataSetID],

(* make sure it's COMPOUND *)
If[
!MatchQ[H5TBasicGetClass["String"][compoundDataTypeID],"COMPOUND"]||Negative[compoundDataTypeID],
CompoundExpression[H5Tclose[compoundDataTypeID],Message[CompoundDataTypeInformation::abort],Abort[]]
],

(* number of members in compound data type*)
numMembers=H5TgetNMembers[compoundDataTypeID],

(* names of members in compound data type *)
memberNames=Table[H5TBasicGetMemberName[compoundDataTypeID,memberIndex],{memberIndex,0,numMembers-1}],

(* IDs for each member *)
memberDataTypeIDs=Table[H5TgetMemberType[compoundDataTypeID,memberIndex],{memberIndex,0,numMembers-1}],

(* class for each member, e.g., "INTEGER" *)
memberClasses=Map[H5TBasicGetClass["String"]][memberDataTypeIDs],

(* system type for each member, e.g., "System.Int32[]", etc. *)
memberSystemTypes=Map[H5TExtendGetSystemType][memberDataTypeIDs],

(* number of system types constituting the individual members *)
memberSystemTypeCountInOneDatumList=Map[H5TExtendGetSystemTypeCountInOneDatum][memberDataTypeIDs],

return={
"NumberOfMembers"->numMembers,
"MemberName"->memberNames,
"MemberClassType"->memberClasses,
"MemberSystemType"->memberSystemTypes,
"MemberSystemTypeCountInOneDatum"->memberSystemTypeCountInOneDatumList
},

(* non-zero StatusFlag indicates an error of some sort occurred*)
statusFlag=Min[H5Tclose[compoundDataTypeID],H5Tclose/@memberDataTypeIDs] ,

(* function's return expression *)
If[Negative[statusFlag],statusFlag,return]
](* close CompoundExpression *)
] (* close H5DExtendOpen *)
] (* close H5FExtendOpen *)
] (* close Module *)


(* ::Input::Initialization:: *)
CompoundDataTypeInformationTree[filename:_String,dataSetPath:_String]:=

Module[
{fileID,dataSetID,topLevelDataTypeID,internalReturn,dataTypeIDlist,classList,systemTypeList,systemTypeCountInOneDatumList},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

H5DExtendOpen[
{dataSetID=H5Dopen[fileID, dataSetPath, H5PuDEFAULT]},

CompoundExpression[

(* get top level ID to initiate activities *)
topLevelDataTypeID=H5DgetType[dataSetID],

(* get the internal tree: example return: {{50331742,"COMPOUND"},{{50331743,"INTEGER"},{50331744,"FLOAT"},{50331745,"FLOAT"},{{50331746,"COMPOUND"},{{50331747,"INTEGER"},{50331748,"FLOAT"}}}}} *)
internalReturn=CompoundDataTypeInformationTree`Internal[topLevelDataTypeID],

(* example return: {50331742,{50331743,50331744,50331745,{50331746,{50331747,50331748}}}} *)
dataTypeIDlist=Replace[internalReturn,{id:_Integer,_String}:>id,All],

(* example return: {"COMPOUND",{"INTEGER","FLOAT","FLOAT",{"COMPOUND",{"INTEGER","FLOAT"}}}}*)
classList=Replace[dataTypeIDlist,id:_Integer:>H5TBasicGetClass["String"][id],All],

(* example return: {"System.Byte[]",{"System.Int32[]","System.Double[]","System.Single[]",{"System.Byte[]",{"System.Int32[]","System.Double[]"}}}}; Drop "System." for visual presentation *)
systemTypeList=Replace[dataTypeIDlist,id:_Integer:>StringDrop[H5TExtendGetSystemType[id],7],All],

(* example return: {28,{1,1,1,{12,{1,1}}}} *)
systemTypeCountInOneDatumList=Replace[dataTypeIDlist,id:_Integer:>H5TExtendGetSystemTypeCountInOneDatum[id],All],

(* close all opened ID's *)
H5Tclose/@Flatten@{dataTypeIDlist},

(* return visualization *)
Replace[classList , {header:_,{content:__}}:>header[content],All]//TreeForm //Print,
Replace[systemTypeList , {header:_,{content:__}}:>header[content],All]//TreeForm // Print,
Replace[systemTypeCountInOneDatumList , {header:_,{content:__}}:>header[content],All]//TreeForm // Print,
Null

](* close CompoundExpression *)
] (* close H5DExtendOpen *)
] (* close H5FExtendOpen *)
] (* close Module *)


(* ::Input::Initialization:: *)
CompoundDataTypeInformationTree`Internal[dataTypeID:_Integer]:=

With[
{class=H5TBasicGetClass["String"][dataTypeID]},

If[
class!="COMPOUND",
{dataTypeID,class},

(*otherwise *)
{
{dataTypeID,class},
(* IDs for each member; recursive application of function to itself *)
Map[CompoundDataTypeInformationTree`Internal][Table[H5TgetMemberType[dataTypeID,memberIndex],{memberIndex,0,H5TgetNMembers[dataTypeID]-1}]]
}
]
]


(* ::Input::Initialization:: *)
Options[ReadHyperSlab]={"FinalIndexFull"->Missing["V2.00 deprecated"]}~Join~Options[H5DExtendRead]


(* ::Input::Initialization:: *)
Options[ReadRank1]=Options[ReadRank2]=Options[ReadRowRank2]=Options[ReadColumnRank2]=Options[ReadHyperSlab]=Options[ReadElementaryPoints]


(* ::Input::Initialization:: *)
ReadRank1[filename:_String,dataSetPath:_String,opts:OptionsPattern[]]:=

ReadHyperSlab[filename,dataSetPath,{},{},opts]



(* ::Input::Initialization:: *)
ReadColumnRank1[filename:_String,dataSetPath:_String]:=

CompoundExpression[
Message[ReadColumnRank1::deprecated],
ReadRank1[filename,dataSetPath]
]



(* ::Input::Initialization:: *)
ReadRank2[filename:_String,dataSetPath:_String,opts:OptionsPattern[]]:=

ReadHyperSlab[filename,dataSetPath,{},{},opts]



(* ::Input::Initialization:: *)
ReadRowRank2[filename:_String,dataSetPath:_String,row:_Integer,opts:OptionsPattern[]]:=

Flatten[ReadHyperSlab[filename,dataSetPath,{row} (*offset*),{1} (*block size*),opts]]



(* ::Input::Initialization:: *)
ReadColumnRank2[filename:_String,dataSetPath:_String,column:_Integer,opts:OptionsPattern[]]:=

With[
{dataSetDimensions=DataSetDimensions[filename,dataSetPath]},

Flatten[ReadHyperSlab[filename,dataSetPath,{1,column} (*offset*),{First@dataSetDimensions,1} (*block size*),opts]]

]



(* ::Input::Initialization:: *)
ReadHyperSlab[filename:_String,dataSetPath:_String,offsetInstructions:_List,blockSizeInstructions:_List,opts:OptionsPattern[]]:=

Module[

{fileID,dataSetID,offsetList,countList,blockSizeList,dataSpaceID,data,statusFlag},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

H5DExtendOpen[
{dataSetID=H5Dopen[fileID, dataSetPath, H5PuDEFAULT]},

CompoundExpression[
(* adjust and fill dimensions as neededed*)
{offsetList,blockSizeList}=ReadHyperSlab`Region[filename,dataSetPath,offsetInstructions,blockSizeInstructions],

(* get spaceID *)
dataSpaceID=H5DgetSpace[dataSetID],

(* one count at offset of blocksize *)
countList=ConstantArray[1,Length@offsetList],

(* set the region of the file to read based on offset and block size *)
H5SselectHyperSlab[dataSpaceID,H5SuSELECTuSET,offsetList-1,Null (*stride*),countList,blockSizeList],

data=H5DExtendRead[dataSetID,dataSpaceID,H5PuDEFAULT,opts],

(* non-zero StatusFlag indicates an error of some sort occurred*)
statusFlag=H5Sclose[dataSpaceID] ,

(* function's return expression *)
If[Negative[statusFlag],statusFlag,data]
](* close CompoundExpression *)
] (* close H5DExtendOpen *)
] (* close H5FExtendOpen *)
] (* close Module *)



(* ::Input::Initialization:: *)
ReadHyperSlab`Region[filename:_String,dataSetPath:_String,offsetInstructions:_List,blockSizeInstructions:_List]:=

Module[

{dataSetDimensions,lengthDifference,offsetList,blockSizeList},

CompoundExpression[

(* full dimensions of data set*)
dataSetDimensions=DataSetDimensions[filename,dataSetPath],

(* as needed, pad with 1 *)
offsetList=PadRight[offsetInstructions,Length@dataSetDimensions,1],

(* difference between rank of provided dimensions and dimensions of dataset; if difference is not zero, then provided dimensions need to be padded for full size of data set*)
lengthDifference=Length[dataSetDimensions]-Length[offsetInstructions],

(* as needed, pad with full dimension of data set *)
blockSizeList=blockSizeInstructions~Join~Take[dataSetDimensions,-lengthDifference],

{offsetList,blockSizeList}

](* close CompoundExpression *)
] (* close Module *)


(* ::Input::Initialization:: *)
ReadElementaryPoints[filename:_String,dataSetPath:_String,elementaryPoints:_List,opts:OptionsPattern[]]:=

Module[

{fileID,dataSetID,dataSpaceID,data,statusFlag},

H5FExtendOpen[
{fileID=H5Fopen[filename,H5FuACCuRDONLY,H5PuDEFAULT]},

H5DExtendOpen[
{dataSetID=H5Dopen[fileID, dataSetPath, H5PuDEFAULT]},

CompoundExpression[

(* get spaceID *)
dataSpaceID=H5DgetSpace[dataSetID],

(* set the region of the file to read based on the list of elementary points *)
H5SBasicSelectElements[dataSpaceID,H5SuSELECTuSET,elementaryPoints-1],

data=H5DExtendRead[dataSetID,dataSpaceID,H5PuDEFAULT,opts],

(* non-zero StatusFlag indicates an error of some sort occurred*)
statusFlag=H5Sclose[dataSpaceID] ,

(* function's return expression *)
If[Negative[statusFlag],statusFlag,data]
](* close CompoundExpression *)
] (* close H5DExtendOpen *)
] (* close H5FExtendOpen *)
] (* close Module *)



(* ::Input::Initialization:: *)
End[]


(* ::Input::Initialization:: *)
SetAttributes[
{NamesAndTypesAtOneNode,NamesAndTypes,DataSetsMetaData,DataSetDimensions,DataSetDataTypeClass,DataSetSystemType,ReadAttributes,CompoundDataTypeInformation,CompoundDataTypeInformationTree,ReadRank1,ReadColumnRank1 (*deprecated*),ReadRank2,ReadRowRank2,ReadColumnRank2,ReadHyperSlab,ReadElementaryPoints},
ReadProtected
]


(* ::Input::Initialization:: *)
EndPackage[]

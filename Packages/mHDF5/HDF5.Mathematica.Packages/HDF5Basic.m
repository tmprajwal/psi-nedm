(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["HDF5Basic`",{"HDF5`","NETLink`"}]


(* ::Input::Initialization:: *)
$HDF5BasicPackageVersion="V2.0"


(* ::Input::Initialization:: *)
H5BasicGetLibVersion::usage=
"H5BasicGetLibVersion[] returns the version of the H5 library as a list of {major, minor, revision}."


(* ::Input::Initialization:: *)
H5ABasicGetName::usage=
"H5ABasicGetName[\"AttributeID\",\"MaximumSize\"] returns {\"ActualSize\", \"Name\"} for a name of upto \"MaximumSize\" in length for the indicated AttributeID. In the case of error, it returns a negative number instead of \"ActualSize\". For a return of just \"ActualSize\", use a call of H5ABasicGetName[\"Size\"][\"AttributeID\",\"MaximumSize\"]. For a return of just \"Name\", use a call of H5ABasicGetName[\"String\"][\"AttributeID\",\"MaximumSize\"]."


(* ::Input::Initialization:: *)
H5ABasicRead::usage=
"H5ABasicRead[\"AttributeID\", \"MemoryTypeID\", \"BufferAsNETObject\"] reads the data of an attribute into the buffer. The \"BufferAsNETObject\" argument should be a NETObject of the system type (e.g., \"System.Int32[]\", \"System.Byte[]\", and so on) that has the correct number of elements for the read operation. The read data are returned to this NETObject. The function returns 0 for success and -1 for failure."


(* ::Input::Initialization:: *)
H5ABasicWrite::usage=
"H5ABasicWrite[\"AttributeID\", \"MemoryTypeID\", \"BufferAsNETObject\"] writes the data of an attribute from a buffer. The \"BufferAsNETObject\" argument should be a NETObject of the system type (e.g., \"System.Int32[]\", \"System.Byte[]\", and so on) that has the correct number of elements for the write operation. The function returns 0 for success and -1 for failure."


(* ::Input::Initialization:: *)
H5DBasicRead::usage=
"H5DBasicRead[\"DataSetID\", \"MemoryTypeID\", \"MemorySpaceID\", \"FileSpaceID\", \"xferPListID\", \"BufferAsNETObject\"] reads data from a file into the buffer. The first 5 arguments are as defined for H5Dread. The \"BufferAsNETObject\" argument should be a NETObject of the system type (e.g., \"System.Int32[]\", \"System.Byte[]\", and so on) that has the correct number of elements for the read operation. The read data are returned to this NETObject. The function returns 0 for success and -1 for failure."


(* ::Input::Initialization:: *)
H5DBasicWrite::usage=
"H5DBasicWrite[\"DataSetID\", \"MemoryTypeID\", \"MemorySpaceID\", \"FileSpaceID\", \"xferPListID\", \"BufferAsNETObject\"] writes data to a file from a buffer. The first 5 arguments are as defined for H5Dwrite. The \"BufferAsNETObject\" argument should be a NETObject of the system type (e.g., \"System.Int32[]\", \"System.Byte[]\", and so on) that has the correct number of elements for the write operation. The function returns 0 for success and -1 for failure."


(* ::Input::Initialization:: *)
H5SBasicGetSimpleExtentDims::usage=
"H5SBasicGetSimpleExtentDims[\"DataSpaceID\"] returns as a list the dimensions of the DataSpaceID."


(* ::Input::Initialization:: *)
H5SBasicGetSelectBounds::usage=
"H5SBasicGetSelectBounds[\"DataSpaceID\"] returns as a {startList,stopList} for the boundaries of selected hyperslab region. Note that the coordinates are -1 relative to the Mathematica expectation. That is, {0,0} in \"C\" convention is returned by this function, whereas Mathematica would use {1,1}."


(* ::Input::Initialization:: *)
H5TBasicGetArrayDims::usage=
"H5TBasicGetArrayDims[\"DataTypeID\"] returns as a list the dimensions of the DataTypeID."


(* ::Input::Initialization:: *)
H5SBasicSelectElements::usage=
"H5SBasicSelectElements[\"DataSpaceID\", \"SelectionOperator\", \"PointList\"] selects a list of points in the \"DataSpaceID\"."


(* ::Input::Initialization:: *)
read[readFunction:_Symbol,bufferForReadDataAsNETObject:_Symbol,arguments:__Integer]:=

NETBlock[

Module[{datumCount,datumSize,bufferSize,intPtrToBuffer,return},

CompoundExpression[

(* get the number of .NET objects in the buffer *)
datumCount=bufferForReadDataAsNETObject@Length[],

(* get the size of each .NET object in bytes *)
datumSize=System`Runtime`InteropServices`Marshal`SizeOf[ReturnAsNETObject[bufferForReadDataAsNETObject@GetValue[0]]],

(* determine the size of needed buffer in bytes *)
bufferSize=Times[datumCount,datumSize],

(* set up unmanaged memory of this buffer size to accept data *)
intPtrToBuffer=System`Runtime`InteropServices`Marshal`AllocHGlobal[bufferSize],

(* initialize unmanaged memory by copying data from managed memory to unmanaged memory. why this step? in case the read function writes to only parts of the buffer, then the return will be what we expect (e.g., for hyperslabs) *)
System`Runtime`InteropServices`Marshal`Copy[bufferForReadDataAsNETObject,0,intPtrToBuffer,datumCount],

(* move data from file to unmanaged memory  *)
return=readFunction[arguments,intPtrToBuffer],

(* move data from unmanaged memory to managed memory *)
System`Runtime`InteropServices`Marshal`Copy[intPtrToBuffer,bufferForReadDataAsNETObject,0,datumCount],

(* garbage cleanup, i.e., release unmanaged memory*)
System`Runtime`InteropServices`Marshal`FreeHGlobal[intPtrToBuffer],
 
(* return; 0 or -1 for success or failure *)
return
]
]
]


(* ::Input::Initialization:: *)
write[writeFunction:_Symbol,bufferToWriteAsNETObject:_Symbol,arguments:__Integer]:=

NETBlock[

Module[{datumCount,datumSize,bufferMemorySize,intPtrToBuffer,dataToWriteNETObject,return},

CompoundExpression[

(* get the number of .NET objects in the buffer *)
datumCount=bufferToWriteAsNETObject@Length[],

(* get the size of each .NET object in bytes *)
datumSize=System`Runtime`InteropServices`Marshal`SizeOf[ReturnAsNETObject[bufferToWriteAsNETObject@GetValue[0]]],

(* determine the size of needed buffer in bytes *)
bufferSize=Times[datumCount,datumSize],

(* set up unmanaged memory to accept data *)
intPtrToBuffer=System`Runtime`InteropServices`Marshal`AllocHGlobal[bufferSize],

(* move data from managed memory to unmanaged memory *)
System`Runtime`InteropServices`Marshal`Copy[bufferToWriteAsNETObject,0,intPtrToBuffer,datumCount],

(* move data from unmanaged memory to file *)
return=writeFunction[arguments,intPtrToBuffer],

(* garbage cleanup, i.e., release unmanaged memory*)
System`Runtime`InteropServices`Marshal`FreeHGlobal[intPtrToBuffer],
 
(* return; return; 0 or -1 for success or failure *)
return
]
]
]


(* ::Input::Initialization:: *)
H5BasicGetLibVersion[]:=
Module[
(* The three symbols should have initial values so that there is memory allocation when Mathematica interfaces with P/Invoke. *)
{major=minor=revision=0,return},
CompoundExpression[
return=H5getUlibversion[major,minor,revision],
If[Negative[return],return,{major,minor,revision}]
]
]


(* ::Input::Initialization:: *)
H5ABasicRead[attributeID:_Integer,memoryTypeID:_Integer,bufferForReadDataAsNETObject:_Symbol]:=
read[H5Aread,bufferForReadDataAsNETObject,attributeID,memoryTypeID]


(* ::Input::Initialization:: *)
H5ABasicWrite[attributeID:_Integer,memoryTypeID:_Integer,bufferToWriteAsNETObject:_Symbol]:=
write[H5Awrite,bufferToWriteAsNETObject,attributeID,memoryTypeID]


(* ::Input::Initialization:: *)
H5ABasicGetName[attributeID:_Integer,size:_Integer]:=

NETBlock[
Module[
{
(* strange .NET errors for NETNew objects of length zero, so set minimums to 1 byte *)
intPtrOfBufferSize=NETNew["System.IntPtr",Max[1,size]],
bufferForReadDataAsNETObject=NETNew["System.Text.StringBuilder",Max[1,size]],
return
},
CompoundExpression[
return=H5AgetName[attributeID,intPtrOfBufferSize,bufferForReadDataAsNETObject],
{return@ToInt32[],bufferForReadDataAsNETObject@ToString[]}
]
]
]


(* ::Input::Initialization:: *)
H5ABasicGetName["String"][attributeID:_Integer,size:_Integer]:=
Module[
{returnList=H5ABasicGetName[attributeID,size]},
(* check for error and return negative result if error or name if no error *)
If[Negative[First@returnList],First@returnList,Last@returnList]
]


(* ::Input::Initialization:: *)
H5ABasicGetName["Size"][attributeID:_Integer,size:_Integer]:=
First@H5ABasicGetName[attributeID,size]


(* ::Input::Initialization:: *)
H5DBasicRead[dataSetID:_Integer,memoryTypeID:_Integer,memorySpaceID:_Integer,fileSpaceID:_Integer, xfer:_Integer,bufferForReadDataAsNETObject:_Symbol]:=
read[H5Dread,bufferForReadDataAsNETObject,dataSetID,memoryTypeID,memorySpaceID,fileSpaceID, xfer]


(* ::Input::Initialization:: *)
H5DBasicWrite[dataSetID:_Integer,memoryTypeID:_Integer,memorySpaceID:_Integer,fileSpaceID:_Integer, xfer:_Integer,bufferToWriteAsNETObject:_Symbol]:=
write[H5Dwrite,bufferToWriteAsNETObject,dataSetID,memoryTypeID,memorySpaceID,fileSpaceID, xfer]


(* ::Input::Initialization:: *)
SetAttributes[H5GBasicGetInfo,HoldRest]


(* ::Input::Initialization:: *)
H5GBasicGetInfoNETObjectTemplate=NETNew["HDF.PInvoke.H5G+info_t"]


(* ::Input::Initialization:: *)
H5GBasicGetInfo[groupID:_Integer,SymbolForReadDataAsNETObject:_Symbol]:=
Module[{status},
CompoundExpression[
(* the call requires the Symbol to already be formatted as the right kind of NETObject; note in the return, however, a new NETObject is produced and the original object is not changed *)
SymbolForReadDataAsNETObject=H5GBasicGetInfoNETObjectTemplate,
status=H5GgetInfo[groupID,SymbolForReadDataAsNETObject],
(* return *) status
]
]


(* ::Input::Initialization:: *)
H5IBasicGetType["String"][objectID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5I+type_t" and we will want to release those resources *)
NETBlock[
H5IgetType[objectID]@ToString[]
]


(* ::Input::Initialization:: *)
H5IBasicGetType["Value"][objectID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5I+type_t" and we will want to release those resources *)
NETBlock[
H5IgetType[objectID]@GetHashCode[]
]


(* ::Input::Initialization:: *)
H5LBasicGetNameByIdx[locationID:_Integer,typeOfIndex:_Symbol,traverseOrder:_Symbol,namePosition:_Integer,size:_Integer,lapl:_Integer]:=

NETBlock[
Module[
{
(* strange .NET errors for NETNew objects of length zero, so set minimums to 1 byte *)
intPtrOfBufferSize=NETNew["System.IntPtr",Max[1,size]],
bufferForReadDataAsNETObject=NETNew["System.Text.StringBuilder",Max[1,size]],
return
},
CompoundExpression[return=H5LgetNameByIdx[locationID,".",typeOfIndex,traverseOrder,namePosition,bufferForReadDataAsNETObject,intPtrOfBufferSize,lapl],
{return@ToInt32[],bufferForReadDataAsNETObject@ToString[]}
]
]
]


(* ::Input::Initialization:: *)
H5LBasicGetNameByIdx["String"][locationID:_Integer,typeOfIndex:_Symbol,traverseOrder:_Symbol,namePosition:_Integer,size:_Integer,lapl:_Integer]:=
Module[
{returnList=H5LBasicGetNameByIdx[locationID,typeOfIndex,traverseOrder,namePosition,size,lapl]},
(* check for error and return negative result if error or name if no error *)
If[Negative[First@returnList],First@returnList,Last@returnList]
]


(* ::Input::Initialization:: *)
H5LBasicGetNameByIdx["Size"][locationID:_Integer,typeOfIndex:_Symbol,traverseOrder:_Symbol,namePosition:_Integer,size:_Integer,lapl:_Integer]:=First@H5LBasicGetNameByIdx[locationID,typeOfIndex,traverseOrder,namePosition,size,lapl]


(* ::Input::Initialization:: *)
SetAttributes[H5OBasicGetInfo,HoldRest]


(* ::Input::Initialization:: *)
H5OBasicGetInfoNETObjectTemplate=NETNew["HDF.PInvoke.H5O+info_t"]


(* ::Input::Initialization:: *)
H5OBasicGetInfo[objectID:_Integer,SymbolForReadDataAsNETObject:_Symbol]:=
Module[{status},
CompoundExpression[
(* the call requires the Symbol to already be formatted as the right kind of NETObject; note in the return, however, a new NETObject is produced and the original object is not changed *)
SymbolForReadDataAsNETObject=H5OBasicGetInfoNETObjectTemplate,
status=H5OgetInfo[objectID,SymbolForReadDataAsNETObject],
(* return *) status
]
]


(* ::Input::Initialization:: *)
SetAttributes[H5OBasicGetInfoByIdx,HoldRest]


(* ::Input::Initialization:: *)
H5OBasicGetInfoByIdx[locationID:_Integer,typeOfIndex:_Symbol,traverseOrder:_Symbol,objectPosition:_Integer,SymbolForReadDataAsNETObject:_Symbol,lapl:_Integer]:=
Module[{status},
CompoundExpression[
(* the call requires the Symbol to already be formatted as the right kind of NETObject; note in the return, however, a new NETObject is produced and the original object is not changed *)
SymbolForReadDataAsNETObject=H5OBasicGetInfoNETObjectTemplate,
status=H5OgetInfoByIdx[locationID,".",typeOfIndex,traverseOrder,objectPosition,SymbolForReadDataAsNETObject,lapl],
(* return *) status
]
]


(* ::Input::Initialization:: *)
H5SBasicGetSelectBounds[dataSpaceID:_Integer]:=

NETBlock[

Module[

{
status,
(* sized by rank of data space *)
startOffsets=NETNew["System.UInt64[]",H5SgetSimpleExtentNDims@dataSpaceID],
stopOffsets=NETNew["System.UInt64[]",H5SgetSimpleExtentNDims@dataSpaceID]
},

CompoundExpression[
status=H5SgetSelectBounds[dataSpaceID,startOffsets,stopOffsets],
(*return*)
If[Negative[status],status,NETObjectToExpression/@{startOffsets,stopOffsets}]
]

]

]


(* ::Input::Initialization:: *)
H5SBasicGetSelectType["String"][dataSpaceID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5S+sel_type" and we will want to release those resources *)
NETBlock[
H5SgetSelectType[dataSpaceID]@ToString[]
]


(* ::Input::Initialization:: *)
H5SBasicGetSelectType["Value"][dataSpaceID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5S+sel_type" and we will want to release those resources *)
NETBlock[
H5SgetSelectType[dataSpaceID]@GetHashCode[]
]


(* ::Input::Initialization:: *)
H5SBasicGetSimpleExtentDims[dataSpaceID:_Integer]:=

NETBlock[

Module[

{
status,
(* sized by rank of data space *)
dataSpaceDimensionsObject=NETNew["System.UInt64[]",H5SgetSimpleExtentNDims@dataSpaceID]
},

CompoundExpression[
status=H5SgetSimpleExtentDims[dataSpaceID,dataSpaceDimensionsObject,Null],
(*return*)
If[Negative[status],status, NETObjectToExpression@dataSpaceDimensionsObject]
]

]

]


(* ::Input::Initialization:: *)
H5SBasicSelectElements[dataSpaceID:_Integer,selectionOperator:_Symbol,points:_List]:=

NETBlock[
With[
{
intPtrSize=NETNew["System.IntPtr",Length@points],
selectedPoints=Flatten[points]
},

H5SselectElements[dataSpaceID,selectionOperator,intPtrSize,selectedPoints]
]
]


(* ::Input::Initialization:: *)
H5TBasicGetArrayDims[arrayDataTypeID:_Integer]:=

NETBlock[

Module[

{
status,
(* sized by rank of data space *)
dataSpaceDimensionsObject=NETNew["System.UInt64[]",H5TgetArrayNDims@arrayDataTypeID]
},

CompoundExpression[
status=H5TgetArrayDims[arrayDataTypeID,dataSpaceDimensionsObject],
(*return*)If[Negative[status],status, NETObjectToExpression@dataSpaceDimensionsObject]
]

]

]


(* ::Input::Initialization:: *)
H5TBasicGetCSet["String"][dataTypeID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+cset_t" and we will want to release those resources *)
NETBlock[
H5TgetCSet[dataTypeID]@ToString[]
]


(* ::Input::Initialization:: *)
H5TBasicGetCSet["Value"][dataTypeID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+cset_t" and we will want to release those resources *)
NETBlock[
H5TgetCSet[dataTypeID]@GetHashCode[]
]


(* ::Input::Initialization:: *)
H5TBasicGetClass["String"][dataTypeID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+class_t" and we will want to release those resources *)
NETBlock[
H5TgetClass[dataTypeID]@ToString[]
]


(* ::Input::Initialization:: *)
H5TBasicGetClass["Value"][dataTypeID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+class_t" and we will want to release those resources *)
NETBlock[
H5TgetClass[dataTypeID]@GetHashCode[]
]


(* ::Input::Initialization:: *)
H5TBasicGetMemberClass["String"][compoundDataTypeID:_Integer,memberIndex:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+class_t" and we will want to release those resources *)
NETBlock[
H5TgetMemberClass[compoundDataTypeID,memberIndex]@ToString[]
]


(* ::Input::Initialization:: *)
H5TBasicGetMemberClass["Value"][compoundDataTypeID:_Integer,memberIndex:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+class_t" and we will want to release those resources *)
NETBlock[
H5TgetMemberClass[compoundDataTypeID,memberIndex]@GetHashCode[]
]


(* ::Input::Initialization:: *)
H5TBasicGetMemberName[compoundDataTypeID:_Integer,memberIndex:_Integer]:=(* the return is a System.IntPtr to a terminated string; we will want to release those resources *)
NETBlock[
Module[{intPtrToBuffer,returnString},
CompoundExpression[
intPtrToBuffer=H5TgetMemberName[compoundDataTypeID,memberIndex],
returnString=System`Runtime`InteropServices`Marshal`PtrToStringAnsi[intPtrToBuffer],
H5freeMemory[intPtrToBuffer],
returnString
]
]
]


(* ::Input::Initialization:: *)
H5TBasicGetMemberOffset[compoundDataTypeID:_Integer,memberIndex:_Integer]:=(* the return is a System.IntPtr and we will want to release those resources *)
NETBlock[
(* the System.IntPtr uses the 'address' as the 'size' *) 
H5TgetMemberOffset[compoundDataTypeID,memberIndex]@ToInt32[]
]


(* ::Input::Initialization:: *)
H5TBasicGetSign["String"][dataTypeID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+sign_t" and we will want to release those resources *)
NETBlock[
H5TgetSign[dataTypeID]@ToString[]
]


(* ::Input::Initialization:: *)
H5TBasicGetSign["Value"][dataTypeID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+sign_t" and we will want to release those resources *)
NETBlock[
H5TgetSign[dataTypeID]@GetHashCode[]
]


(* ::Input::Initialization:: *)
H5TBasicGetSize[dataTypeID:_Integer]:=
(* the return is a System.IntPtr and we will want to release those resources *)
NETBlock[
(* the System.IntPtr uses the 'address' as the 'size' *) 
H5TgetSize[dataTypeID]@ToInt32[]
]


(* ::Input::Initialization:: *)
H5TBasicGetStrPad["String"][dataTypeID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+str_t" and we will want to release those resources *)
NETBlock[
H5TgetStrPad[dataTypeID]@ToString[]
]


(* ::Input::Initialization:: *)
H5TBasicGetStrPad["Value"][dataTypeID:_Integer]:=
(* the return is a NETObject of "HDF.PInvoke.H5T+str_t" and we will want to release those resources *)
NETBlock[
H5TgetStrPad[dataTypeID]@GetHashCode[]
]


(* ::Input::Initialization:: *)
H5TBasicSetSize[dataTypeID:_Integer,size:_Integer]:=
NETBlock[
With[
{intPtrToSize=NETNew["System.IntPtr",size]},
H5TsetSize[dataTypeID,intPtrToSize]
]
]


(* ::Input::Initialization:: *)
EndPackage[]
